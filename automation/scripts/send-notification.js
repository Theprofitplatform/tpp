#!/usr/bin/env node

/**
 * Send notifications about blog post generation results
 * Supports: Slack, Email (future), Discord (future)
 */

const STATUS = process.env.STATUS || 'unknown';
const POST_TITLE = process.env.POST_TITLE || 'Unknown Post';
const POST_URL = process.env.POST_URL || '';
const SLUG = process.env.SLUG || '';
const WORD_COUNT = process.env.WORD_COUNT || '0';
const GITHUB_REPOSITORY = process.env.GITHUB_REPOSITORY || '';
const GITHUB_RUN_ID = process.env.GITHUB_RUN_ID || '';
const GITHUB_SERVER_URL = process.env.GITHUB_SERVER_URL || 'https://github.com';

async function sendNotification() {
  try {
    console.log('\nüì£ Sending notifications...\n');

    const workflowUrl = GITHUB_REPOSITORY && GITHUB_RUN_ID
      ? `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`
      : '';

    // Send to Slack
    if (process.env.SLACK_WEBHOOK_URL) {
      await sendSlackNotification(workflowUrl);
    } else {
      console.log('‚ö†Ô∏è  No SLACK_WEBHOOK_URL configured, skipping Slack notification');
    }

    // Future: Email notifications
    if (process.env.EMAIL_NOTIFICATION_ENABLED) {
      await sendEmailNotification(workflowUrl);
    }

    console.log('‚úÖ Notifications sent\n');

  } catch (error) {
    console.error('‚ùå Failed to send notification:', error.message);
    // Don't fail the workflow if notifications fail
    console.warn('‚ö†Ô∏è  Continuing anyway (notifications are non-critical)\n');
  }
}

/**
 * Send Slack notification with rich formatting
 */
async function sendSlackNotification(workflowUrl) {
  const webhook = process.env.SLACK_WEBHOOK_URL;

  if (!webhook) return;

  console.log('üì§ Sending Slack notification...');

  const payload = STATUS === 'success'
    ? buildSuccessMessage(workflowUrl)
    : buildErrorMessage(workflowUrl);

  const response = await fetch(webhook, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(`Slack API error: ${response.statusText}`);
  }

  console.log('   ‚úì Slack notification sent');
}

/**
 * Build success message for Slack
 */
function buildSuccessMessage(workflowUrl) {
  return {
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚úÖ New Blog Post Published!',
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Title:*\n${POST_TITLE}`
          },
          {
            type: 'mrkdwn',
            text: `*Word Count:*\n${WORD_COUNT} words`
          },
          {
            type: 'mrkdwn',
            text: `*Slug:*\n\`${SLUG}\``
          },
          {
            type: 'mrkdwn',
            text: `*Status:*\n:hourglass: Building...`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*URL:* ${POST_URL}\n\n:information_source: Post will be live in ~5 minutes after Cloudflare Pages completes the build.`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Post',
              emoji: true
            },
            url: POST_URL,
            style: 'primary'
          },
          ...(workflowUrl ? [{
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Workflow',
              emoji: true
            },
            url: workflowUrl
          }] : [])
        ]
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `:robot_face: Generated by automated blog system ‚Ä¢ ${new Date().toLocaleString('en-AU', { timeZone: 'Australia/Sydney' })}`
          }
        ]
      }
    ]
  };
}

/**
 * Build error message for Slack
 */
function buildErrorMessage(workflowUrl) {
  return {
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚ùå Blog Post Generation Failed',
          emoji: true
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:warning: *Blog post generation workflow failed*\n\nPlease check the workflow logs to see what went wrong.`
        }
      },
      ...(POST_TITLE && POST_TITLE !== 'Unknown Post' ? [{
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Attempted Topic:*\n${POST_TITLE}`
          }
        ]
      }] : []),
      {
        type: 'actions',
        elements: [
          ...(workflowUrl ? [{
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Logs',
              emoji: true
            },
            url: workflowUrl,
            style: 'danger'
          }] : [])
        ]
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `:robot_face: Automated blog system alert ‚Ä¢ ${new Date().toLocaleString('en-AU', { timeZone: 'Australia/Sydney' })}`
          }
        ]
      }
    ]
  };
}

/**
 * Send email notification (future implementation)
 */
async function sendEmailNotification(workflowUrl) {
  console.log('üìß Email notifications not yet implemented');

  // Future: Integration with SendGrid, Mailgun, or AWS SES
  // const subject = STATUS === 'success'
  //   ? `‚úÖ New Blog Post: ${POST_TITLE}`
  //   : `‚ùå Blog Generation Failed`;
  //
  // const htmlContent = STATUS === 'success'
  //   ? buildSuccessEmail()
  //   : buildErrorEmail();
  //
  // await sendEmail({
  //   to: process.env.NOTIFICATION_EMAIL,
  //   subject,
  //   html: htmlContent
  // });
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  sendNotification();
}

export { sendNotification };
